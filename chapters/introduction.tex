\section{Introduction}
WASM (or WebAssembly), is an open standard binary code format close to assembly. Its initial objective is to provide an alternative to java-script and better performance in the current web ecosystems. Benefit from its platform independence, front-end flexibility (can be compiled from the majority languages including C, C++, assembly script, rust, etc.), good isolated run-time and speed that close to native binary, its usage start to arise in distributed cloud and edge computing. Recently it becomes a popular binary format for users to running customized functions on AWS Lambda, Open Yurt, AZURE, etc.

As with the technology of WASM run-time for cloud and edge computing shifts, security and privacy \cite{ pearson2009taking} issues emerge in scenarios that demanding trustless \cite{wood2016trustless, chang2002trustless} computation and privacy computing \cite{xiao2012security,takabi2010security}. For instance, suppose that there is a voting hub  hosted in the cloud to collect votes for proposals. The role of this service is to reporting voting result to users while does not leaking any information of any voter's choice. In this scenario, we would like the service does not only provide the voting result but also provide a proof to convince users that the provided result is calculated with predefined protocols (voting protocols). However since the service can not leak voters' personal choice, they should not reveal any voting ticket that is signed by a voter which makes it tricky to make a proof. 

Traditional ways to achieve trustless and privacy usually involves invasive changes to the source code of the service running on cloud and those changes are usually applied in a case by case manner. In this work, instead of change the code itself, we propose a novel approach by implementing \zkwasm, which is a WASM virtualy machine that does not only runs the WASM bytecode but also provides a zero-knowledge proof which is used to convince a verifier that the execution result is trustworthy.

The idea of \zkwasm\, is derived from ZKSNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) which is a combination of SNARG (Succinct non-interactive arguments) and zero-knowledge proof. In general, adoption of ZKSNARK usually requires implementing program in arithmetic circuits (see Section \ref{chp:arith-circuits}) which forms a barrier for existing programs to leverage the power of it. Thus in this paper, we writes the whole WASM virtual machine in ZKSNARK circuits so that existing WASM applications can benifit from ZKSNARK by simply running on the \zkwasm\, without any modification. Therefore, the cloud service provider can prove to any user that the computation result is computed honestly and no privacy information is leaked.

\smallskip\noindent\textbf{The Problem.}
To implement a ZKSNARK backed WASM virtual machine, we need to connect the implementation of WASM runtime with the prove system of ZKSNARK. In general, a ZKSNARK system is represented in arithmetic circuits (see Section \ref{chp:arith-circuits}) with polynomial constraints. Therefore we need to abstract the full imperative logic of a WASM virtual machine systematically and rewrite it into arithmetic circuits with constraints. Given two outputs, one is generated by emulating the WASM bytecode in WASM runtime that enforce the semantic of WASM specification, and the other satisfies the constraints imposed on the arithemtic circuits, if the circuits we write preserves the semantic, then these two ouputs must be same. Thus the proof of the ZKSNARKS derived from the circuits also shows that the output is valid as a result of emulating the bytecode in WASM runtime. 

\smallskip\noindent\textbf{Our Contribution.}
In this paper we systematically abstract the WASM runtime implementaion and rewrite it into arithmetic circuits with constraints. By doing so, we proposed and implemented the first zk-WASM virtual machine that supports web assembly specification. Moreover, by providing \zkwasm\, existing program compiled to WASM (without any modification) can then satisfy the privacy and trustless requirements that recently emerges in cloud and edge computing.

\smallskip\noindent\textbf{Organization of the Paper.}
After a brief introduction about the basic ideas about how to connect statefull virtual machine with SNARK in Section \ref{chp:preliminary}, we describe the basic building block and ingredients use used to construct \zkwasm circuits in Section \ref{chp:constraint-system} and then presents the circuits architecture in Section \ref{chp:architecture-circuits}. After the architecture is fixed, we list circuit of each opcode of WASM in Section \ref{chp:instruction-circuits}. In Section \ref{chp:foreign} we discuss foreign instruction expansion which provides a way to extend the virtual machine for better performance and integration. In the end, we discuss the performance benchmark in Section \ref{chp:performance}.

\section{Preliminaries}
\label{chp:preliminary}
\subsection{Succinct Verification}
Succinct non-interactive arguments (SNARGs) enable verifying NP statements with lower complexity than required for classical NP verification. Traditionally, the focus has been on minimizing the length of such arguments; nowadays researches have focused also on minimizing verification time, by drawing motivation from the problem of delegating computation.

Recent constructions of preprocessing SNARGs have achieved attractive features: they are publicly-verifiable, proofs consist of only O(1) encrypted (or encoded) field elements, and verification is via arithmetic circuits of size linear in the NP statement. Additionally, these constructions seem to have “escaped the hegemony” of probabilistically-checkable proofs (PCPs) as a basic building block of succinct arguments.


\subsection{Polynomial Commitment Schemes}
PCS (Polynomial Commitment Schemes \cite{boneh2020halo-pcs,boneh2020efficient-pcs,kate2010polynomial-pcs}) is a powerful tool to construct SNARK schemes for the statement of polynomial evaluation. PCS provides a way for prover and verifier to commit to a polynomial $p$ and then open the commitment at certain any point (prove that the evaluation of $P$ a point $x$ is equal to a claimed value $v$). In this paper, if without specification, We use KZG (Kate, Zaverucha and Goldberg) as our polynomial commitment scheme and the commitment formula for a polynomial $p$ is defined by $g^{p(\beta)}$ where $\beta$ is a random value negioated by prover and verifier at setup stage and $g$ is a point on a special elliptic curve.

\subsection{Stateless Programs as Arithmetic Circuits}
\label{chp:arith-circuits}
Once there exists a SNARK scheme for a prover to prove the evaluation of polynomials $p_i$ at $x_i$ to a verifier, we can then construct SNARK for a prover to prove that a program $P(X)$ has certain return value $v$ when input $X$ is provided. Many such construction can be found in literature such as Groth, Sonic, Marlin, Plonk, etc. In this paper, we construct our ZK virtual machine using the proof system of Halo2, which is an extension of PLONK (See Section \ref{chp:constraint-system}). In PLONK setup, stateless programs can be encoded into a special format called arithmetic circuits.

An arithmetic circuit is a set of gates and each gates can have a set of inputs that need to be processed and a set of outputs that can be used as other gates' inputs. The gates can be connected together so as to carry out an arithmetic algorithm. In the end, the outputs of the circuit is result of the algorithm. For example, suppose that we need to represent an sum algorithm can be constructed by a list of add gates as in Figure \ref{fig:sum-gates}.

\begin{figure}[!ht]
\centerline{
\includegraphics[scale=0.8]{figs/arithment-circuit.png}
}
\caption{Arithment Circuit of Sum}\label{fig:sum-gates}
\end{figure}

Now we have connected stateless programs to arithmetic circuits, and we know how to construct SNARKS of polynomial evaluation using PCS. Therefore it remains to establish a connection between arithmetic circuits with polynomials. This can be achieved by using interpolation techniques and copy constraints in PLONKish (see Section \ref{chp:constraint-system}).

%PCS 是polynomialbase的，constraint base ---> PCS
\subsection{Connecting Stateful Virtual Machine with Arithmetic Circuits}
\label{chp:encode-state-in-circuits}
Now we need to make a setup further, instead of construct a SNARK scheme for stateless programs, we would like to construct a SNARK scheme for a stateful virtual machine. We do not constructing such SNARK from scratch, we construct it from the knowing ingredients which are the arithmetic circuits in Section \ref{chp:arith-circuits}. 

To start with, we establish the connection between a virtual machine and a program by treating the virtual machine as a program which generates a list of state transitions and each transition is defined as a monad function between states. We denote the transition function as $T_i$ which takes an input $s:State$ and outputs a new state $s':S$. The type of state $\mathcal{S}$ is defined as a tuple of \fullstate \, where $\mathcal{F}$ is the calling frame, $\mathcal{M}$ is the memory state, $\mathcal{S}_p$ is stack and $\mathcal{I}$ is the image which contains code image $\mathcal{C}$ and initial memory $\mathcal{H}$.

Also for an instruction $op$ at address $addr$ in the image $\mathcal{I}$ of a WASM binary file, we define the transition semantic of $op$ to be a pair of $(t^{addr}_{op}, c^{addr}_{op})$ where $t^{address}_{op}$ is a state transition function and $c^{addr}_{op}$ is the control flow function from $S$ to the address of next instruction.

To define a valid sequence of transitions $T_i$, we first requires that $T_0$ enforces the transition semantic of the instruction at the entry point $iaddr$ and for all $addr, s, k$, $T_k(s) = t^{iaddr}_{op}(s) \rightarrow T_{k+1} = t_{op'}^{iaddr'}$ where $iaddr' = c_{op}^{iaddr}(s)$ and $op'$ is the opcode of the instruction at $'iaddr$.

Second, with this setup we can mapping execution of a executable image $I$ in a virtual machine $\mathcal{V}_m$ to a sequence of transition function $T_i$ over an initial state $s_0$. By denoting $s_i = T_i (T_{i-1}(\cdots T_0(s_0)))$ and $s_e$ to be the last state of the transition sequence, We require the final opcode of $T_{e}$ is return and the depth of the calling frame of $s_e$ is zero $\mathcal{F}(s_e).depth = 0$.

We say a system of arithmetic circuits $C$ of transitions is equivalent to a WASM virtual machine if for any given entry point $iaddr_0$ there exists a unique sequence of $T_i$ satisfies $C$ and $T_0 = c^{iaddr_0}_{op}$.

%Stateless -> Statefull 的虚拟机：monadic function while s is hash
\subsection{Leverage zero-knowledge in ZKWASM}
A zk-SNARK is a SNARK scheme that provide a way for a prover to prove statements without leaking any information. When we construct the above SNARK scheme for virtual machine in a zero-knowledge way, then we create a ZK Virtual machine that can prove the execution of certain program image without leaking any information.  This feature makes the ZK virtual machine extremely useful in scenarios where the prover would like to prove that certain ouput is calculated from execution a particular program image but does not want to leak the data used.
 
