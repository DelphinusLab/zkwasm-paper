\section{Introduction}
WASM (or WebAssembly) is an open standard binary code format close to assembly. Its initial objective is to provide an alternative to java-script with better performance in the current web ecosystems. Benefiting from its platform independence, front-end flexibility (can be compiled from the majority of languages including C, C++, assembly script, rust, etc.), good isolated runtime and speed that is close to native binary, its usage starts to arise in the distributed cloud and edge computing. Recently it has become a popular binary format for users to run customized functions on AWS Lambda, Open Yurt, AZURE, etc.

As with the technology of WASM runtime for cloud and edge computing shifts, security and privacy \cite{pearson2009taking, gadepalli2020sledge-wasmsec} issues emerge in scenarios that demand trustless computation \cite{wood2016trustless, chang2002trustless, mcfadden2018security} and privacy computing \cite{xiao2012security,takabi2010security}. For instance, suppose that there is a voting hub hosted in the cloud to collect votes for proposals. The role of this service is to report the voting results to users while not leaking any information about any voters' choices. In this scenario, we would like a service that not only provides the voting results but also provides proof to convince users that the provided results are calculated with predefined protocols (voting protocols). However, since the service cannot leak voters' personal choices, it should not reveal any information about the voting tickets that are signed by voters, which makes it tricky to provide evidence of the result. 

Traditional ways to achieve trustlessness and privacy usually involve invasive modification \cite{jin2012proof-tl,chong2013enforcing-tl, crary2003foundational-tl, azzedin2002evolving-tl} to the source code of the service running on the cloud and those changes are usually applied in a case-by-case manner. In this work, instead of changing the code itself, we propose a novel approach by implementing \zkwasm, which is a WASM virtual machine that not only runs the WASM bytecode but also provides a zero-knowledge proof to convince a verifier that the execution result is trustworthy.

The idea of \zkwasm\, is derived from ZKSNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) \cite{ben2013snarks, groth2016size, partala2020non-snark-survey}, which is a combination of SNARG (Succinct non-interactive arguments) and zero-knowledge proof. In general, the adoption of ZKSNARK usually requires implementing a program in arithmetic circuits or circuit-friendly languages (Pinocchio \cite{parno2016pinocchio,jawurekzero-pin}, TinyRAM \cite{ben2013snarks-4c}, Buffet/Pequin \cite{wahby2014efficient-ram}, Geppetto \cite{costello2015geppetto}, xJsnark framework \cite{kosba2018xjsnark}, ZoKrates \cite{eberhardt2018zokrates}) that forms a barrier for existing programs to leverage the power of it. An alternative way is that instead of applying \zksnark\, on the source code, we apply it on the bytecode level of a virtual machine and implement a \zksnark-backed virtual machine (Similar ideas can be found in Risc0 \cite{risczero} and ZKEVM \cite{begassat2021specification-zkevm, different-zkevms} while the underlying bytecode they support has less flexibility and portability for cloud application). In this work, we take the approach of writing the whole WASM virtual machine in ZKSNARK circuits so that existing WASM applications can benefit from ZKSNARK by simply running on the \zkwasm\, without any modification. Therefore, the cloud service provider can prove to any user that the computation result is computed honestly and no private information is leaked.

\smallskip\noindent\textbf{The Problem.}
To implement a ZKSNARK-backed WASM virtual machine, we need to connect the implementation of WASM runtime with the proof system of ZKSNARK. In general, a ZKSNARK system is represented in arithmetic circuits with polynomial constraints. Therefore we need to abstract the full imperative logic of a WASM virtual machine systematically and rewrite it into arithmetic circuits with constraints. Given two outputs, one is generated by emulating the WASM bytecode in WASM runtime that enforces the semantics of WASM specification, and the other satisfies the constraints imposed on the arithmetic circuits. If the circuits we write preserve the semantics, these two outputs must be the same. Hence the proof of the ZKSNARK derived from the circuits also shows that the output is valid as a result of emulating the bytecode in WASM runtime. 

\smallskip\noindent\textbf{Our Contribution.}
In this paper, we systematically abstract the WASM runtime implementation and rewrite it into arithmetic circuits with constraints. By doing so, we have proposed and implemented the first ZKSNARK WASM virtual machine that supports WASM specification and produce succinct zero-knowledge correctness proofs of the execution result. Moreover, by providing \zkwasm, an existing program compiled to WASM can then satisfy (without any modification)  the privacy and trustless requirements that have recently emerged in the cloud and edge computing.

\smallskip\noindent\textbf{Organization of the Paper.}
After a brief introduction to the basic ideas about how to connect a stateful virtual machine with ZKSNARK in Section \ref{chp:preliminary}, we describe the basic building block and ingredients used to construct \zkwasm\, circuits in Section \ref{chp:build-blocks} and then present the circuits architecture in Section \ref{chp:architecture-circuits}. After the architecture is settled, we discuss the circuits of every category of WASM instructions in Section \ref{chp:instruction-circuits}. In addition, in Section \ref{chp:foreign} we discuss foreign instruction expansion which provides a way to extend the virtual machine for better performance and integration. In Section \ref{chp:sharding-batching}, we present the partition and proof batching technique to solve the long execution trace problem, and then discuss the performance benchmark in Section \ref{chp:performance}. In the end, we draw our conclusion and pursue the future work in Section \ref{chp:conclusion}.  

